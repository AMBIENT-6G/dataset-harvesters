<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Harvester CSV Export</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f3ef;
      --card: #ffffff;
      --ink: #1a1a1a;
      --accent: #1f4f7a;
      --muted: #5b5b5b;
      --border: #d8d1c7;
    }
    body {
      margin: 0;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--ink);
    }
    .wrap {
      max-width: 1080px;
      margin: 32px auto 48px;
      padding: 0 20px;
    }
    header {
      margin-bottom: 20px;
    }
    h1 {
      font-size: 28px;
      margin: 0 0 6px;
    }
    p {
      margin: 0;
      color: var(--muted);
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.04);
    }
    fieldset {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin: 0 0 18px;
    }
    legend {
      font-weight: 600;
      padding: 0 6px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px 16px;
    }
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .term-name {
      border-bottom: 1px dotted #9fb0c1;
      cursor: help;
    }
    .term-info {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid #aebdcb;
      background: #eef3f8;
      color: #1f4f7a;
      font-size: 11px;
      line-height: 1;
      cursor: help;
      user-select: none;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 14px;
    }
    select {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      background: #fff;
    }
    .filter-dropdown {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
    }
    .filter-dropdown summary {
      padding: 8px 10px;
      cursor: pointer;
      user-select: none;
      font-size: 14px;
      list-style: none;
    }
    .filter-dropdown summary::-webkit-details-marker {
      display: none;
    }
    .filter-dropdown summary::after {
      content: "v";
      float: right;
      color: #6b7785;
    }
    .filter-dropdown[open] summary::after {
      content: "^";
    }
    .filter-options {
      border-top: 1px solid var(--border);
      padding: 8px 10px;
      max-height: 170px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .filter-option {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .filter-options-empty {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }
    .actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }
    button:hover {
      background: #183c5c;
    }
    button.secondary {
      background: #dfe6ee;
      color: #1f2a35;
    }
    button.secondary:hover {
      background: #c8d2dd;
    }
    .note {
      font-size: 13px;
      color: var(--muted);
    }
    .errors {
      background: #fff3f3;
      border: 1px solid #f1b4b4;
      color: #8a1c1c;
      padding: 12px 14px;
      border-radius: 10px;
      margin-bottom: 16px;
      white-space: pre-line;
    }
    .hidden {
      display: none;
    }
    .chart-area {
      margin-top: 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      background: #fbfaf8;
    }
    .chart-filters {
      margin-top: 12px;
    }
    .chart-filters .note {
      margin-bottom: 8px;
    }
    .chart-area canvas {
      width: 100%;
      height: 360px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Harvester CSV Export</h1>
      <p>Select one or more harvesters and parameters, then download a CSV export or plot a chart.</p>
    </header>

    <div class="card">
      <div id="error" class="errors hidden"></div>
      <p id="loading-note" class="note">Loading JSON data...</p>
      <p id="empty-note" class="note hidden">No data available to export.</p>

      <form id="export-form">
        <fieldset>
          <legend>Harvesters</legend>
          <div id="harvester-list" class="grid"></div>
        </fieldset>

        <fieldset>
          <legend>Parameters (CSV export)</legend>
          <div id="column-list" class="grid"></div>
        </fieldset>

        <div class="actions">
          <label>
            <input type="checkbox" id="include-harvester" checked>
            Include harvester name column
          </label>
          <button type="button" id="download-button">Download CSV</button>
        </div>
        <p class="note">Tip: selecting multiple harvesters automatically adds the harvester column to the export.</p>

        <fieldset>
          <legend>Chart</legend>
          <div class="grid">
            <div class="field">
              <span>X axis</span>
              <select id="x-axis"></select>
            </div>
            <div class="field">
              <span>Y axis</span>
              <select id="y-axis"></select>
            </div>
          </div>
          <div class="chart-filters">
            <p class="note">Optional filters for non X/Y columns. Open a dropdown and tick multiple boxes; each value set appears as a separate series.</p>
            <div id="chart-filter-list" class="grid"></div>
          </div>
          <div class="actions" style="margin-top: 12px;">
            <button type="button" id="clear-filters-button" class="secondary">Clear Filters</button>
            <button type="button" id="plot-button" class="secondary">Plot Chart</button>
            <button type="button" id="download-chart-button" class="secondary">Download Chart CSV</button>
          </div>
          <p class="note">Chart uses numeric values only. Choose numeric columns for X/Y axes.</p>
        </fieldset>

        <div class="chart-area">
          <canvas id="harvester-chart"></canvas>
        </div>
      </form>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const HARVESTERS = [
      { name: 'AEM40940', file: './json-export/AEM40940.json' },
      { name: 'P1110B', file: './json-export/P1110B.json' },
      { name: 'P2110B', file: './json-export/P2110B.json' },
      { name: 'SMS7621005LF', file: './json-export/SMS7621005LF.json' },
      { name: 'SMS7630005LF', file: './json-export/SMS7630005LF.json' },
      { name: 'sSUHFIPTIVA0', file: './json-export/sSUHFIPTIVA0.json' }
    ];

    const errorBox = document.getElementById('error');
    const loadingNote = document.getElementById('loading-note');
    const emptyNote = document.getElementById('empty-note');
    const harvesterList = document.getElementById('harvester-list');
    const columnList = document.getElementById('column-list');
    const includeHarvester = document.getElementById('include-harvester');
    const downloadButton = document.getElementById('download-button');
    const xAxisSelect = document.getElementById('x-axis');
    const yAxisSelect = document.getElementById('y-axis');
    const chartFilterList = document.getElementById('chart-filter-list');
    const clearFiltersButton = document.getElementById('clear-filters-button');
    const plotButton = document.getElementById('plot-button');
    const downloadChartButton = document.getElementById('download-chart-button');
    const chartCanvas = document.getElementById('harvester-chart');

    const CHART_FILTER_EXCLUDED_KEYS = new Set([
      'pwr_pw',
      'buffer_voltage_mv',
      'resistance',
    ]);
    const DEFAULT_X_AXIS_KEY = 'level_dbm';
    const DEFAULT_Y_AXIS_KEY = 'efficiency';

    const harvesterData = new Map();
    let columnKeys = [];
    let termMetaByKey = {};
    let chartInstance = null;

    function showError(message) {
      errorBox.textContent = message;
      errorBox.classList.remove('hidden');
    }

    function clearError() {
      errorBox.textContent = '';
      errorBox.classList.add('hidden');
    }

    function fallbackLabelFromKey(key) {
      return key
        .split('_')
        .filter(Boolean)
        .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function termMetaForKey(key) {
      if (termMetaByKey[key]) {
        return termMetaByKey[key];
      }
      return {
        name: fallbackLabelFromKey(key),
        explanation: ''
      };
    }

    function normalizeTermMeta(payload) {
      const normalized = {};
      if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
        return normalized;
      }

      if (Array.isArray(payload.terms)) {
        payload.terms.forEach((term) => {
          if (!term || typeof term !== 'object') {
            return;
          }
          const key = typeof term.key === 'string' ? term.key.trim() : '';
          const name = typeof term.name === 'string' ? term.name.trim() : '';
          const explanation = typeof term.explanation === 'string' ? term.explanation.trim() : '';
          if (!key || !name || !explanation) {
            return;
          }
          normalized[key] = { name, explanation };
        });
        return normalized;
      }

      Object.entries(payload).forEach(([key, value]) => {
        if (!value || typeof value !== 'object' || Array.isArray(value)) {
          return;
        }
        const name = typeof value.name === 'string' ? value.name.trim() : '';
        const explanation = typeof value.explanation === 'string' ? value.explanation.trim() : '';
        if (!name || !explanation) {
          return;
        }
        normalized[key] = { name, explanation };
      });
      return normalized;
    }

    async function loadTermMeta() {
      try {
        const response = await fetch('../terms.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error('HTTP ' + response.status);
        }
        const payload = await response.json();
        const normalized = normalizeTermMeta(payload);
        if (Object.keys(normalized).length === 0) {
          throw new Error('Unexpected glossary format');
        }
        termMetaByKey = normalized;
      } catch (err) {
        termMetaByKey = {};
        console.warn('Failed to load glossary metadata:', err);
      }
    }

    function renderCheckboxes(container, items, name, options = {}) {
      const labelForItem = options.labelForItem || ((item) => ({ name: item, explanation: '' }));
      const showInfo = options.showInfo || false;
      container.innerHTML = '';
      items.forEach((item) => {
        const itemLabel = labelForItem(item);
        const label = document.createElement('label');
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.name = name;
        input.value = item;
        input.checked = true;
        if (itemLabel.explanation) {
          label.title = itemLabel.explanation;
        }
        label.appendChild(input);
        const text = document.createElement('span');
        text.textContent = itemLabel.name;
        if (itemLabel.explanation) {
          text.className = 'term-name';
          text.title = itemLabel.explanation;
        }
        label.appendChild(text);
        if (showInfo && itemLabel.explanation) {
          const info = document.createElement('span');
          info.className = 'term-info';
          info.textContent = 'i';
          info.title = itemLabel.explanation;
          info.setAttribute('aria-label', itemLabel.explanation);
          label.appendChild(info);
        }
        container.appendChild(label);
      });
    }

    function setSelectTitle(select, labelForItem) {
      const itemLabel = labelForItem(select.value);
      select.title = itemLabel.explanation || '';
    }

    function renderSelect(select, items, fallbackIndex, options = {}) {
      const labelForItem = options.labelForItem || ((item) => ({ name: item, explanation: '' }));
      select.innerHTML = '';
      items.forEach((item, idx) => {
        const itemLabel = labelForItem(item);
        const option = document.createElement('option');
        option.value = item;
        option.textContent = itemLabel.name;
        if (itemLabel.explanation) {
          option.title = itemLabel.explanation;
        }
        select.appendChild(option);
        if (idx === fallbackIndex) {
          select.value = item;
        }
      });
      setSelectTitle(select, labelForItem);
    }

    function selectedValues(container) {
      return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map((input) => input.value);
    }

    function normalizeFilterValue(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value);
    }

    function buildChartFilterValues(columnKey, harvesterNames) {
      const values = new Set();
      harvesterNames.forEach((name) => {
        const rows = harvesterData.get(name) || [];
        rows.forEach((row) => {
          if (!row || typeof row !== 'object') {
            return;
          }
          if (!Object.prototype.hasOwnProperty.call(row, columnKey)) {
            return;
          }
          values.add(normalizeFilterValue(row[columnKey]));
        });
      });
      return Array.from(values).sort((a, b) => a.localeCompare(b, undefined, {
        numeric: true,
        sensitivity: 'base',
      }));
    }

    function filterValueLabel(value) {
      return value === '' ? '(empty)' : value;
    }

    function selectedDropdownValues(dropdown) {
      return Array.from(dropdown.querySelectorAll('input[type="checkbox"]:checked')).map((input) => input.value);
    }

    function updateFilterDropdownSummary(dropdown) {
      const summary = dropdown.querySelector('summary');
      if (!summary) {
        return;
      }
      const selected = selectedDropdownValues(dropdown).map((value) => filterValueLabel(value));
      if (selected.length === 0) {
        summary.textContent = 'Any';
        return;
      }
      if (selected.length <= 2) {
        summary.textContent = selected.join(', ');
        return;
      }
      summary.textContent = selected.slice(0, 2).join(', ') + ' +' + (selected.length - 2);
    }

    function renderChartFilters() {
      if (!chartFilterList || columnKeys.length === 0) {
        return;
      }

      const previousSelections = new Map();
      chartFilterList.querySelectorAll('details[data-filter-key]').forEach((dropdown) => {
        previousSelections.set(
          dropdown.dataset.filterKey,
          new Set(selectedDropdownValues(dropdown))
        );
      });

      chartFilterList.innerHTML = '';

      const selectedHarvesters = selectedValues(harvesterList);
      const activeHarvesters = selectedHarvesters.length
        ? selectedHarvesters
        : HARVESTERS.filter((item) => harvesterData.has(item.name)).map((item) => item.name);
      const xKey = xAxisSelect.value;
      const yKey = yAxisSelect.value;
      const filterKeys = columnKeys.filter(
        (key) => key !== xKey && key !== yKey && !CHART_FILTER_EXCLUDED_KEYS.has(key)
      );

      filterKeys.forEach((key) => {
        const itemLabel = termMetaForKey(key);
        const values = buildChartFilterValues(key, activeHarvesters);

        const field = document.createElement('div');
        field.className = 'field';

        const name = document.createElement('span');
        name.textContent = itemLabel.name;
        if (itemLabel.explanation) {
          name.className = 'term-name';
          name.title = itemLabel.explanation;
        }
        field.appendChild(name);

        const dropdown = document.createElement('details');
        dropdown.className = 'filter-dropdown';
        dropdown.dataset.filterKey = key;
        if (itemLabel.explanation) {
          dropdown.title = itemLabel.explanation;
        }

        const summary = document.createElement('summary');
        summary.textContent = 'Any';
        dropdown.appendChild(summary);

        const options = document.createElement('div');
        options.className = 'filter-options';

        const previousValues = previousSelections.get(key);
        if (values.length === 0) {
          const emptyNote = document.createElement('p');
          emptyNote.className = 'filter-options-empty';
          emptyNote.textContent = 'No values';
          options.appendChild(emptyNote);
        } else {
          values.forEach((value) => {
            const optionLabel = document.createElement('label');
            optionLabel.className = 'filter-option';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = value;
            if (previousValues && previousValues.has(value)) {
              checkbox.checked = true;
            }
            checkbox.addEventListener('change', () => updateFilterDropdownSummary(dropdown));

            const text = document.createElement('span');
            text.textContent = filterValueLabel(value);

            optionLabel.appendChild(checkbox);
            optionLabel.appendChild(text);
            options.appendChild(optionLabel);
          });
        }

        dropdown.appendChild(options);
        updateFilterDropdownSummary(dropdown);

        field.appendChild(dropdown);
        chartFilterList.appendChild(field);
      });
    }

    function selectedChartFilters() {
      const filters = new Map();
      chartFilterList.querySelectorAll('details[data-filter-key]').forEach((dropdown) => {
        const values = new Set(selectedDropdownValues(dropdown));
        if (values.size > 0) {
          filters.set(dropdown.dataset.filterKey, values);
        }
      });
      return filters;
    }

    function clearChartFilters() {
      chartFilterList.querySelectorAll('details[data-filter-key]').forEach((dropdown) => {
        dropdown.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
          checkbox.checked = false;
        });
        updateFilterDropdownSummary(dropdown);
      });
    }

    function preferredAxisIndex(columns, preferredKey, fallbackIndex) {
      const index = columns.indexOf(preferredKey);
      if (index >= 0) {
        return index;
      }
      return fallbackIndex;
    }

    function rowFilterSignature(row, filters) {
      const parts = [];
      for (const [key, values] of filters.entries()) {
        const value = normalizeFilterValue(row[key]);
        if (!values.has(value)) {
          return null;
        }
        parts.push({ key, value });
      }
      return parts;
    }

    function formatFilterParts(parts) {
      if (!parts || parts.length === 0) {
        return '';
      }
      return parts
        .map((part) => termMetaForKey(part.key).name + '=' + (part.value === '' ? '(empty)' : part.value))
        .join(', ');
    }

    function updateHarvesterToggle() {
      const selected = selectedValues(harvesterList);
      if (selected.length > 1) {
        includeHarvester.checked = true;
        includeHarvester.disabled = true;
      } else {
        includeHarvester.disabled = false;
      }
    }

    function getColor(index) {
      const palette = ['#1f4f7a', '#b4573c', '#5b7c32', '#7a4f8b', '#d48c2d', '#2c6d7a'];
      return palette[index % palette.length];
    }

    function csvEscape(value) {
      if (value === null || value === undefined) {
        return '';
      }
      const text = String(value);
      if (/[",\n\r]/.test(text)) {
        return '"' + text.replace(/"/g, '""') + '"';
      }
      return text;
    }

    function buildCsv(selectedHarvesters, selectedColumns) {
      const includeColumn = includeHarvester.checked || selectedHarvesters.length > 1;
      const header = includeColumn ? ['harvester', ...selectedColumns] : [...selectedColumns];
      const lines = [header.map(csvEscape).join(',')];

      selectedHarvesters.forEach((name) => {
        const rows = harvesterData.get(name) || [];
        rows.forEach((row) => {
          const line = [];
          if (includeColumn) {
            line.push(csvEscape(name));
          }
          selectedColumns.forEach((col) => {
            line.push(csvEscape(row[col] ?? ''));
          });
          lines.push(line.join(','));
        });
      });

      return lines.join('\n');
    }

    function triggerCsvDownload(csv, filenamePrefix) {
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filenamePrefix + '-' + new Date().toISOString().replace(/[:.]/g, '-') + '.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function buildChartSeriesData(selectedHarvesters, xKey, yKey, chartFilters) {
      const series = new Map();
      const signatureKeys = new Set();
      const harvesterOrder = new Map(selectedHarvesters.map((name, idx) => [name, idx]));

      selectedHarvesters.forEach((name) => {
        const rows = harvesterData.get(name) || [];
        rows.forEach((row) => {
          const signatureParts = rowFilterSignature(row, chartFilters);
          if (signatureParts === null) {
            return;
          }

          const xVal = Number.parseFloat(row[xKey]);
          const yVal = Number.parseFloat(row[yKey]);
          if (!Number.isFinite(xVal) || !Number.isFinite(yVal)) {
            return;
          }

          const signatureKey = signatureParts
            .map((part) => part.key + '\u0000' + part.value)
            .join('\u0001');
          signatureKeys.add(signatureKey);
          const seriesKey = name + '\u0002' + signatureKey;
          if (!series.has(seriesKey)) {
            series.set(seriesKey, {
              harvester: name,
              signatureKey,
              signatureParts,
              points: [],
            });
          }
          series.get(seriesKey).points.push({ x: xVal, y: yVal });
        });
      });

      if (series.size === 0) {
        return null;
      }

      const sortedSignatureKeys = Array.from(signatureKeys).sort((a, b) => a.localeCompare(b));
      const signatureIndex = new Map(sortedSignatureKeys.map((key, idx) => [key, idx]));
      const sortedSeries = Array.from(series.values()).sort((a, b) => {
        const harvesterDiff = (harvesterOrder.get(a.harvester) ?? 0) - (harvesterOrder.get(b.harvester) ?? 0);
        if (harvesterDiff !== 0) {
          return harvesterDiff;
        }
        return (signatureIndex.get(a.signatureKey) ?? 0) - (signatureIndex.get(b.signatureKey) ?? 0);
      });

      sortedSeries.forEach((entry) => {
        entry.points.sort((a, b) => a.x - b.x);
      });

      return { sortedSeries, signatureIndex };
    }

    function downloadCsv() {
      clearError();
      const selectedHarvesters = selectedValues(harvesterList);
      const selectedColumns = selectedValues(columnList);

      if (selectedHarvesters.length === 0) {
        showError('Select at least one harvester.');
        return;
      }
      if (selectedColumns.length === 0) {
        showError('Select at least one parameter.');
        return;
      }

      const csv = buildCsv(selectedHarvesters, selectedColumns);
      if (!csv.trim()) {
        showError('No data available for the selected harvesters.');
        return;
      }

      triggerCsvDownload(csv, 'harvester-data');
    }

    function buildChartCsv(sortedSeries, xKey, yKey, activeFilterKeys) {
      const header = ['harvester', 'series', xKey, yKey, ...activeFilterKeys];
      const lines = [header.map(csvEscape).join(',')];

      sortedSeries.forEach((entry) => {
        const suffix = formatFilterParts(entry.signatureParts);
        const seriesLabel = suffix ? entry.harvester + ' (' + suffix + ')' : entry.harvester;
        const filterValuesByKey = new Map(
          entry.signatureParts.map((part) => [part.key, part.value])
        );

        entry.points.forEach((point) => {
          const line = [entry.harvester, seriesLabel, point.x, point.y];
          activeFilterKeys.forEach((key) => {
            line.push(filterValuesByKey.get(key) ?? '');
          });
          lines.push(line.map(csvEscape).join(','));
        });
      });

      return lines.join('\n');
    }

    function downloadChartCsv() {
      clearError();
      const selectedHarvesters = selectedValues(harvesterList);
      if (selectedHarvesters.length === 0) {
        showError('Select at least one harvester.');
        return;
      }
      if (!xAxisSelect.value || !yAxisSelect.value) {
        showError('Select both an X axis and Y axis.');
        return;
      }

      const xKey = xAxisSelect.value;
      const yKey = yAxisSelect.value;
      const chartFilters = selectedChartFilters();
      const chartData = buildChartSeriesData(selectedHarvesters, xKey, yKey, chartFilters);
      if (!chartData) {
        showError('No numeric chart data available for the selected axes and filters.');
        return;
      }

      const activeFilterKeys = Array.from(chartFilters.keys());
      const chartCsv = buildChartCsv(chartData.sortedSeries, xKey, yKey, activeFilterKeys);
      triggerCsvDownload(chartCsv, 'harvester-chart-data');
    }

    function plotChart() {
      clearError();
      const selectedHarvesters = selectedValues(harvesterList);
      if (selectedHarvesters.length === 0) {
        showError('Select at least one harvester.');
        return;
      }
      if (!xAxisSelect.value || !yAxisSelect.value) {
        showError('Select both an X axis and Y axis.');
        return;
      }

      const xKey = xAxisSelect.value;
      const yKey = yAxisSelect.value;
      const chartFilters = selectedChartFilters();
      const chartData = buildChartSeriesData(selectedHarvesters, xKey, yKey, chartFilters);
      if (!chartData) {
        showError('No numeric data available for the selected axes and filters.');
        return;
      }

      const datasets = [];
      const colorByHarvester = new Map(
        selectedHarvesters.map((name, idx) => [name, getColor(idx)])
      );
      chartData.sortedSeries.forEach((entry) => {
        const color = colorByHarvester.get(entry.harvester) || getColor(0);
        const suffix = formatFilterParts(entry.signatureParts);
        const label = suffix ? entry.harvester + ' (' + suffix + ')' : entry.harvester;
        datasets.push({
          label,
          data: entry.points,
          borderColor: color,
          backgroundColor: color,
          pointRadius: 3,
          showLine: false,
        });
      });

      if (chartInstance) {
        chartInstance.destroy();
      }

      chartInstance = new Chart(chartCanvas.getContext('2d'), {
        type: 'scatter',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top' },
          },
          scales: {
            x: {
              title: { display: true, text: termMetaForKey(xKey).name },
            },
            y: {
              title: { display: true, text: termMetaForKey(yKey).name },
            },
          },
        },
      });
    }

    async function loadData() {
      clearError();
      loadingNote.classList.remove('hidden');

      const columns = new Set();
      const loadErrors = [];

      for (const harvester of HARVESTERS) {
        try {
          const response = await fetch(harvester.file, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error('HTTP ' + response.status);
          }
          const payload = await response.json();
          if (!Array.isArray(payload)) {
            throw new Error('Unexpected JSON format');
          }
          harvesterData.set(harvester.name, payload);
          payload.forEach((row) => {
            if (row && typeof row === 'object') {
              Object.keys(row).forEach((key) => columns.add(key));
            }
          });
        } catch (err) {
          loadErrors.push(harvester.name + ': ' + (err instanceof Error ? err.message : 'failed to load'));
        }
      }

      loadingNote.classList.add('hidden');

      if (loadErrors.length) {
        showError('Some JSON files failed to load:\n' + loadErrors.join('\n'));
      }

      if (harvesterData.size === 0) {
        emptyNote.classList.remove('hidden');
        return;
      }

      const harvesterNames = HARVESTERS.filter((item) => harvesterData.has(item.name)).map((item) => item.name);
      const columnListData = Array.from(columns);
      columnKeys = columnListData;
      const columnLabelForItem = (item) => termMetaForKey(item);

      renderCheckboxes(harvesterList, harvesterNames, 'harvesters');
      renderCheckboxes(columnList, columnListData, 'columns', {
        labelForItem: columnLabelForItem,
        showInfo: true
      });
      const xAxisDefaultIndex = preferredAxisIndex(columnListData, DEFAULT_X_AXIS_KEY, 0);
      const yAxisDefaultIndex = preferredAxisIndex(
        columnListData,
        DEFAULT_Y_AXIS_KEY,
        columnListData.length > 1 ? 1 : 0
      );
      renderSelect(xAxisSelect, columnListData, xAxisDefaultIndex, { labelForItem: columnLabelForItem });
      renderSelect(yAxisSelect, columnListData, yAxisDefaultIndex, { labelForItem: columnLabelForItem });

      const handleHarvesterChange = () => {
        updateHarvesterToggle();
        renderChartFilters();
      };
      const handleAxisChange = (select) => {
        setSelectTitle(select, columnLabelForItem);
        renderChartFilters();
      };

      updateHarvesterToggle();
      renderChartFilters();
      harvesterList.addEventListener('change', handleHarvesterChange);
      xAxisSelect.addEventListener('change', () => handleAxisChange(xAxisSelect));
      yAxisSelect.addEventListener('change', () => handleAxisChange(yAxisSelect));
    }

    downloadButton.addEventListener('click', downloadCsv);
    clearFiltersButton.addEventListener('click', clearChartFilters);
    plotButton.addEventListener('click', plotChart);
    downloadChartButton.addEventListener('click', downloadChartCsv);
    async function init() {
      await loadTermMeta();
      await loadData();
    }

    init();
  </script>
</body>
</html>
